// DOMAIN: Identity Provider - Authentication Messages
// COMPLIANCE: SOC 2 CC6.1, GDPR Article 5, NIST 800-63B, ISO 27001 A.9.2
// SECURITY: Authentication required, tenant isolation enforced
// PII: Contains email, phone, user identifiers

syntax = "proto3";

package geniustechspace.idp.authn.v1;

import "buf/validate/validate.proto";
import "core/client/v1/messages.proto";
import "core/device/v1/messages.proto";
import "core/network/v1/messages.proto";
import "google/protobuf/timestamp.proto";
import "idp/api/v1/common.proto";
import "idp/api/v1/enums.proto";
import "idp/authn/v1/enums.proto";

option csharp_namespace = "GeniusTechSpace.Protobuf.Idp.Authn.V1";
option go_package = "github.com/geniustechspace/protobuf/gen/go/idp/authn/v1;idpauthnv1";
option java_multiple_files = true;
option java_package = "com.geniustechspace.protobuf.idp.authn.v1";

// AuthenticateRequest initiates authentication.
// COMPLIANCE: NIST 800-63B Section 4.1 (Authentication Process)
// AUTHENTICATION: Public endpoint (no auth required)
// RATE LIMIT: 10/min per IP, 5/min per user
message AuthenticateRequest {
  // Tenant ID. REQUIRED.
  string tenant_id = 1 [(buf.validate.field).string.min_len = 1];

  // Authentication method. REQUIRED.
  idp.api.v1.AuthenticationMethod method = 2 [(buf.validate.field).enum.defined_only = true];

  // Credential proof. REQUIRED.
  // Use oneof for type-safe credential submission.
  oneof proof {
    PasswordProof password = 3;
    EmailProof email = 4;
    SmsProof sms = 5;
    WebAuthnProof webauthn = 6;
    BiometricProof biometric = 7;
    SocialProof social = 8;
    ApiKeyProof api_key = 9;
    CertificateProof certificate = 10;
  }

  // Device context. OPTIONAL.
  // For device binding and risk assessment.
  core.device.v1.DeviceContext device_context = 11;

  // Client context. OPTIONAL.
  // For client fingerprinting and feature detection.
  core.client.v1.ClientContext client_context = 12;

  // Network context. OPTIONAL.
  // For IP-based risk assessment.
  core.network.v1.NetworkContext network_context = 13;

  // Remember device. OPTIONAL.
  // Whether to remember this device for future logins.
  bool remember_device = 14;

  // Scopes requested. OPTIONAL.
  // OAuth 2.0 scopes.
  repeated string scopes = 15;

  // Metadata. OPTIONAL.
  map<string, string> metadata = 16;
}

// PasswordProof for password-based authentication.
// SECURITY: Password transmitted over TLS 1.3+, never logged
message PasswordProof {
  // Identifier. REQUIRED.
  // Email, username, or phone number.
  // PII: Yes - GDPR Article 4(1) personal identifier
  string identifier = 1 [(buf.validate.field).string.min_len = 1];

  // Password. REQUIRED.
  // SECURITY: Never logged, transmitted over TLS 1.3+ only
  // ENCRYPTION: TLS in transit, bcrypt/argon2id at rest
  string password = 2 [(buf.validate.field).string = {
    min_len: 8
    max_len: 128
  }];
}

// EmailProof for passwordless email authentication.
message EmailProof {
  // Email address. REQUIRED.
  // PII: Yes - GDPR Article 4(1) personal identifier
  string email = 1 [(buf.validate.field).string.email = true];

  // Code. OPTIONAL.
  // For code-based verification. Mutually exclusive with token.
  string code = 2 [(buf.validate.field).string = {
    min_len: 6
    max_len: 8
  }];

  // Token. OPTIONAL.
  // For magic link verification. Mutually exclusive with code.
  string token = 3;
}

// SmsProof for SMS-based authentication.
message SmsProof {
  // Phone number. REQUIRED.
  // PII: Yes - GDPR Article 4(1) personal identifier
  // VALIDATION: E.164 format
  string phone_number = 1 [(buf.validate.field).string.pattern = "^\\+[1-9]\\d{1,14}$"];

  // Code. REQUIRED.
  string code = 2 [(buf.validate.field).string = {
    min_len: 6
    max_len: 8
  }];
}

// WebAuthnProof for WebAuthn/FIDO2 authentication.
// COMPLIANCE: W3C WebAuthn Level 2
message WebAuthnProof {
  // Credential ID. REQUIRED.
  // Base64-encoded credential ID from registration.
  string credential_id = 1 [(buf.validate.field).string.min_len = 1];

  // Authenticator data. REQUIRED.
  // Base64-encoded authenticator data.
  bytes authenticator_data = 2 [(buf.validate.field).bytes.min_len = 37];

  // Client data JSON. REQUIRED.
  // Base64-encoded client data JSON.
  bytes client_data_json = 3 [(buf.validate.field).bytes.min_len = 1];

  // Signature. REQUIRED.
  // Base64-encoded signature.
  bytes signature = 4 [(buf.validate.field).bytes.min_len = 1];

  // User handle. OPTIONAL.
  // Base64-encoded user handle.
  bytes user_handle = 5;
}

// BiometricProof for biometric authentication.
message BiometricProof {
  // Biometric type. REQUIRED.
  idp.api.v1.BiometricType type = 1 [(buf.validate.field).enum.defined_only = true];

  // Template ID. REQUIRED.
  // Reference to stored biometric template.
  string template_id = 2 [(buf.validate.field).string.min_len = 1];

  // Biometric data. REQUIRED.
  // Encrypted biometric sample for verification.
  // SECURITY: Always encrypted, never stored
  bytes biometric_data = 3 [(buf.validate.field).bytes.min_len = 1];

  // Liveness score. OPTIONAL.
  // Anti-spoofing liveness detection score (0-100).
  int32 liveness_score = 4 [(buf.validate.field).int32 = {
    gte: 0
    lte: 100
  }];
}

// SocialProof for social login authentication.
message SocialProof {
  // Provider. REQUIRED.
  idp.api.v1.SocialProvider provider = 1 [(buf.validate.field).enum.defined_only = true];

  // Authorization code. REQUIRED.
  // OAuth 2.0 authorization code from social provider.
  string authorization_code = 2 [(buf.validate.field).string.min_len = 1];

  // Redirect URI. OPTIONAL.
  // Must match registered redirect URI.
  string redirect_uri = 3;

  // State. OPTIONAL.
  // CSRF protection state parameter.
  string state = 4;
}

// ApiKeyProof for API key authentication.
message ApiKeyProof {
  // API key. REQUIRED.
  // SECURITY: Transmitted over TLS 1.3+, never logged
  string api_key = 1 [(buf.validate.field).string.min_len = 32];
}

// CertificateProof for X.509 certificate authentication.
message CertificateProof {
  // Certificate. REQUIRED.
  // PEM-encoded X.509 certificate.
  string certificate = 1 [(buf.validate.field).string.min_len = 1];

  // Challenge signature. REQUIRED.
  // Signature of challenge using certificate private key.
  bytes challenge_signature = 2 [(buf.validate.field).bytes.min_len = 1];

  // Challenge. REQUIRED.
  // Random challenge that was signed.
  string challenge = 3 [(buf.validate.field).string.min_len = 1];
}

// AuthenticateResponse returns authentication result.
message AuthenticateResponse {
  // Status. REQUIRED.
  idp.api.v1.AuthenticationStatus status = 1 [(buf.validate.field).enum.defined_only = true];

  // Success. REQUIRED.
  bool success = 2;

  // Session ID. OPTIONAL.
  // Only if authentication successful or MFA required.
  string session_id = 3;

  // Access token. OPTIONAL.
  // Only if authentication successful and MFA not required.
  string access_token = 4;

  // Refresh token. OPTIONAL.
  // Only if authentication successful and MFA not required.
  string refresh_token = 5;

  // ID token. OPTIONAL.
  // OpenID Connect ID token.
  string id_token = 6;

  // Expires in. OPTIONAL.
  // Token expiration in seconds.
  int32 expires_in = 7;

  // Token type. OPTIONAL.
  // Usually "Bearer".
  string token_type = 8;

  // MFA required. REQUIRED.
  bool mfa_required = 9;

  // MFA methods. OPTIONAL.
  // Available MFA methods if mfa_required is true.
  repeated idp.api.v1.MFAType mfa_methods = 10;

  // User ID. OPTIONAL.
  // PII: Yes - GDPR Article 4(1) personal identifier
  string user_id = 11;

  // Risk level. OPTIONAL.
  idp.api.v1.RiskLevel risk_level = 12;

  // Risk score. OPTIONAL.
  // Risk assessment score (0-100).
  int32 risk_score = 13 [(buf.validate.field).int32 = {
    gte: 0
    lte: 100
  }];

  // Message. OPTIONAL.
  // Human-readable message.
  string message = 14;

  // Authenticated at. OPTIONAL.
  google.protobuf.Timestamp authenticated_at = 15;
}

// VerifyMFARequest verifies multi-factor authentication.
// AUTHENTICATION: Requires valid session from AuthenticateResponse
// RATE LIMIT: 5/min per session
message VerifyMFARequest {
  // Tenant ID. REQUIRED.
  string tenant_id = 1 [(buf.validate.field).string.min_len = 1];

  // Session ID. REQUIRED.
  // From AuthenticateResponse.
  string session_id = 2 [(buf.validate.field).string.min_len = 1];

  // MFA method. REQUIRED.
  idp.api.v1.MFAType method = 3 [(buf.validate.field).enum.defined_only = true];

  // MFA proof. REQUIRED.
  oneof proof {
    TotpProof totp = 4;
    SmsProof sms = 5;
    EmailProof email = 6;
    WebAuthnProof webauthn = 7;
    BiometricProof biometric = 8;
    BackupCodeProof backup_code = 9;
  }

  // Remember device. OPTIONAL.
  bool remember_device = 10;
}

// TotpProof for TOTP verification.
message TotpProof {
  // Code. REQUIRED.
  // 6-digit TOTP code.
  string code = 1 [(buf.validate.field).string.pattern = "^[0-9]{6}$"];
}

// BackupCodeProof for backup code verification.
message BackupCodeProof {
  // Code. REQUIRED.
  // Single-use backup recovery code.
  string code = 1 [(buf.validate.field).string = {
    min_len: 8
    max_len: 16
  }];
}

// VerifyMFAResponse returns MFA verification result.
message VerifyMFAResponse {
  // Status. REQUIRED.
  idp.api.v1.AuthenticationStatus status = 1 [(buf.validate.field).enum.defined_only = true];

  // Success. REQUIRED.
  bool success = 2;

  // Access token. OPTIONAL.
  // Only if verification successful.
  string access_token = 3;

  // Refresh token. OPTIONAL.
  string refresh_token = 4;

  // ID token. OPTIONAL.
  string id_token = 5;

  // Expires in. OPTIONAL.
  int32 expires_in = 6;

  // Token type. OPTIONAL.
  string token_type = 7;

  // Message. OPTIONAL.
  string message = 8;

  // Remaining backup codes. OPTIONAL.
  // If backup code was used.
  int32 remaining_backup_codes = 9;
}

// LogoutRequest terminates session.
// AUTHENTICATION: Requires valid access token or session
message LogoutRequest {
  // Tenant ID. REQUIRED.
  string tenant_id = 1 [(buf.validate.field).string.min_len = 1];

  // User ID. REQUIRED.
  // PII: Yes - GDPR Article 4(1) personal identifier
  string user_id = 2 [(buf.validate.field).string.min_len = 1];

  // Session ID. OPTIONAL.
  // If specified, logout this specific session.
  // If not specified, logout current session.
  string session_id = 3;

  // Logout all. OPTIONAL.
  // Whether to logout all sessions.
  bool logout_all = 4;

  // Revoke tokens. OPTIONAL.
  // Whether to revoke all tokens.
  bool revoke_tokens = 5;
}

// LogoutResponse confirms logout.
message LogoutResponse {
  // Success. REQUIRED.
  bool success = 1;

  // Sessions terminated. OPTIONAL.
  // Number of sessions terminated.
  int32 sessions_terminated = 2;

  // Tokens revoked. OPTIONAL.
  // Number of tokens revoked.
  int32 tokens_revoked = 3;

  // Message. OPTIONAL.
  string message = 4;
}
