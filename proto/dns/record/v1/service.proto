// DOMAIN: DNS - Record Management Service
// COMPLIANCE: SOC 2 CC6.1, RFC 1035, ISO 27001 A.12.1.2
// SECURITY: All RPCs require authentication and tenant isolation
// PII: No - Records do not contain personal data

syntax = "proto3";

package geniustechspace.dns.record.v1;

import "dns/record/v1/messages.proto";

option go_package = "github.com/geniustechspace/protobuf/gen/go/dns/record/v1;dnsrecordv1";

// RecordService manages DNS records within domains.
// COMPLIANCE: SOC 2 CC6.1, RFC 1035 (DNS Standards)
// SECURITY: All methods require authentication and enforce tenant isolation
// AUDIT: All mutating operations are logged for compliance
service RecordService {
  // CreateRecord creates a new DNS record within a domain.
  // AUTHENTICATION: Required - valid bearer token
  // AUTHORIZATION: Requires 'dns:records:create' permission
  // COMPLIANCE: SOC 2 CC6.1 (Resource provisioning), RFC 1035
  // RATE LIMIT: 100 requests/minute per tenant
  // IDEMPOTENCY: Safe to retry with same parameters within tenant
  // AUDIT: Logs record creation with user identity
  //
  // Request validation:
  // - tenant_path: Required, max 512 chars
  // - domain_id: Required, must exist and belong to tenant
  // - name: Valid DNS label format
  // - type: Must be defined record type
  // - value: Format validated per record type
  // - ttl: 60-86400 seconds
  //
  // Type-specific validation:
  // - A: value must be valid IPv4 address
  // - AAAA: value must be valid IPv6 address
  // - CNAME: value must be FQDN, cannot coexist with other records at same name
  // - MX: priority required, value must be FQDN
  // - SRV: priority, weight, port required, value must be FQDN
  // - TXT: value max 64KB, multiple strings allowed
  // - CAA: value must be valid CAA format
  //
  // Business rules:
  // - CNAME records cannot coexist with other types at same name
  // - Wildcard records (*) have specific constraints
  // - SOA records typically managed by system, not user-created
  // - Record starts in PENDING_PROPAGATION status
  //
  // Side effects:
  // - Triggers DNS propagation (5 min to 48 hours)
  // - May trigger health checks if configured
  // - Updates zone serial number
  //
  // Error codes:
  // - INVALID_ARGUMENT: Invalid record format or validation failure
  // - NOT_FOUND: Domain not found or not in tenant
  // - ALREADY_EXISTS: Conflicting record exists (e.g., CNAME conflict)
  // - PERMISSION_DENIED: Insufficient permissions
  // - RESOURCE_EXHAUSTED: Rate limit exceeded
  // - FAILED_PRECONDITION: Domain not in valid state for record creation
  rpc CreateRecord(CreateRecordRequest) returns (CreateRecordResponse);

  // GetRecord retrieves a single DNS record by ID.
  // AUTHENTICATION: Required - valid bearer token
  // AUTHORIZATION: Requires 'dns:records:read' permission
  // COMPLIANCE: SOC 2 CC6.1 (Data access control)
  // RATE LIMIT: 1000 requests/minute per tenant
  // CACHE: Response cacheable for 60 seconds
  //
  // Request validation:
  // - tenant_path: Required
  // - record_id: Required, valid UUID/ULID
  //
  // Response:
  // - Returns full Record entity with health status
  // - Includes propagation status if available
  // - Soft-deleted records not returned (404 error)
  //
  // Error codes:
  // - INVALID_ARGUMENT: Invalid record_id format
  // - NOT_FOUND: Record not found or deleted
  // - PERMISSION_DENIED: Insufficient permissions or wrong tenant
  rpc GetRecord(GetRecordRequest) returns (GetRecordResponse);

  // ListRecords retrieves DNS records with pagination, filtering, and sorting.
  // AUTHENTICATION: Required - valid bearer token
  // AUTHORIZATION: Requires 'dns:records:list' permission
  // COMPLIANCE: SOC 2 CC6.1 (Data access control)
  // RATE LIMIT: 100 requests/minute per tenant
  // CACHE: Response cacheable for 30 seconds
  //
  // Pagination:
  // - Cursor-based for optimal performance (O(log n))
  // - Default page_size: 20, max: 100
  // - See PaginationRequest for details
  //
  // Filtering (filter):
  // - Allowed fields: type, status, health_status, tags, name, domain_id
  // - Operators: =, !=, AND, OR, IN
  // - Examples:
  //   - "type='RECORD_TYPE_A'"
  //   - "status='RECORD_STATUS_ACTIVE' AND type='RECORD_TYPE_A'"
  //   - "domain_id='dom_123' AND health_status='HEALTH_CHECK_STATUS_HEALTHY'"
  //   - "tags IN ['production', 'web-server']"
  //
  // Sorting (order_by):
  // - Allowed fields: name, type, ttl, status, created_at, updated_at
  // - Format: "field_name [asc|desc]"
  // - Default: "name asc"
  // - Examples: "created_at desc", "name asc, type asc"
  //
  // Response:
  // - Returns list of records (soft-deleted excluded)
  // - Includes pagination metadata
  // - May include propagation status for each record
  //
  // Error codes:
  // - INVALID_ARGUMENT: Invalid pagination, order_by, or filter syntax
  // - NOT_FOUND: Domain not found (if domain_id filter used)
  // - PERMISSION_DENIED: Insufficient permissions
  // - RESOURCE_EXHAUSTED: Rate limit exceeded
  rpc ListRecords(ListRecordsRequest) returns (ListRecordsResponse);

  // UpdateRecord updates an existing DNS record.
  // AUTHENTICATION: Required - valid bearer token
  // AUTHORIZATION: Requires 'dns:records:update' permission
  // COMPLIANCE: SOC 2 CC6.1 (Change management), SOC 2 CC6.3 (Audit trail)
  // RATE LIMIT: 100 requests/minute per tenant
  // CONCURRENCY: Optimistic locking via version field
  // AUDIT: Logs all changes with field-level audit trail
  //
  // Request validation:
  // - tenant_path: Required
  // - record_id: Required
  // - update_mask: Required (specifies fields to update)
  // - version: Required (for optimistic locking)
  //
  // Updatable fields:
  // - value: New record value (type-specific validation)
  // - ttl: Time to live
  // - priority, weight, port: For MX/SRV records
  // - tags: Record tags
  // - metadata: Custom metadata
  // - comment: Description
  // - status: Lifecycle status (admin only)
  //
  // Immutable fields (cannot be updated):
  // - record_id, domain_id, tenant_path
  // - name, type, class: Changing these requires delete+create
  // - created_at
  //
  // Business rules:
  // - Record type cannot be changed (delete + create instead)
  // - Updates trigger DNS propagation
  // - CNAME constraints still enforced
  // - Health checks may be re-triggered
  //
  // Side effects:
  // - Triggers DNS propagation (5 min to 48 hours)
  // - Resets propagation status to PENDING
  // - May trigger health checks
  // - Updates zone serial number
  //
  // Response:
  // - Returns updated Record entity
  // - version field incremented
  //
  // Error codes:
  // - INVALID_ARGUMENT: Invalid field values or update_mask
  // - NOT_FOUND: Record not found or deleted
  // - ABORTED: Version mismatch (concurrent modification detected)
  // - FAILED_PRECONDITION: Update not allowed in current state
  // - PERMISSION_DENIED: Insufficient permissions
  // - RESOURCE_EXHAUSTED: Rate limit exceeded
  rpc UpdateRecord(UpdateRecordRequest) returns (UpdateRecordResponse);

  // DeleteRecord soft-deletes a DNS record (sets deleted_at timestamp).
  // AUTHENTICATION: Required - valid bearer token
  // AUTHORIZATION: Requires 'dns:records:delete' permission
  // COMPLIANCE: SOC 2 CC6.1, SOC 2 CC6.3 (Audit trail)
  // RATE LIMIT: 100 requests/minute per tenant
  // CONCURRENCY: Optimistic locking via version field
  // AUDIT: Logs deletion with user identity and timestamp
  //
  // Soft delete behavior:
  // - Sets deleted_at timestamp
  // - Preserves data for audit compliance
  // - Excludes from List operations
  // - Record stops serving DNS queries immediately
  //
  // Request validation:
  // - tenant_path: Required
  // - record_id: Required
  // - version: Required (for optimistic locking)
  //
  // Side effects:
  // - Removes record from DNS zone
  // - Triggers DNS propagation
  // - Stops health checks
  // - Updates zone serial number
  //
  // Business rules:
  // - Cannot delete SOA record (system managed)
  // - Cannot delete last NS record (would break zone)
  // - Deletion is permanent after retention period
  //
  // Response:
  // - Empty on success
  //
  // Error codes:
  // - INVALID_ARGUMENT: Invalid record_id
  // - NOT_FOUND: Record not found or already deleted
  // - ABORTED: Version mismatch (concurrent modification detected)
  // - FAILED_PRECONDITION: Cannot delete critical record (SOA, last NS)
  // - PERMISSION_DENIED: Insufficient permissions
  // - RESOURCE_EXHAUSTED: Rate limit exceeded
  //
  // NOTE: For hard deletion (compliance erasure), use separate administrative API
  rpc DeleteRecord(DeleteRecordRequest) returns (DeleteRecordResponse);

  // ResolveRecord performs DNS name resolution query.
  // AUTHENTICATION: Required - valid bearer token
  // AUTHORIZATION: Requires 'dns:records:resolve' permission
  // COMPLIANCE: SOC 2 CC6.1, RFC 1035
  // RATE LIMIT: 1000 requests/minute per tenant
  // CACHE: Response cacheable based on record TTL
  //
  // Purpose:
  // - Query DNS records by fully qualified domain name
  // - Simulate DNS resolver behavior
  // - Useful for validation and testing
  //
  // Request validation:
  // - tenant_path: Required
  // - fqdn: Required, valid DNS name
  // - type: Optional (if omitted, returns all types)
  //
  // Resolution behavior:
  // - Returns only ACTIVE records
  // - Follows CNAME chains
  // - Respects DNS precedence rules
  // - Returns multiple records for round-robin
  //
  // Response:
  // - Returns matching records
  // - Includes TTL for caching
  // - Empty list if name does not exist
  //
  // Filtering:
  // - If type specified, returns only that type
  // - If type omitted, returns all record types
  // - Excludes soft-deleted records
  // - Excludes PENDING/FAILED status records
  //
  // Use cases:
  // - Validate record configuration
  // - Test DNS resolution
  // - Preview changes before propagation
  // - Troubleshooting DNS issues
  //
  // Error codes:
  // - INVALID_ARGUMENT: Invalid FQDN format or record type
  // - PERMISSION_DENIED: Insufficient permissions
  // - RESOURCE_EXHAUSTED: Rate limit exceeded
  //
  // NOTE: This queries internal database, not actual DNS infrastructure
  // For actual DNS queries, use external DNS resolver tools
  rpc ResolveRecord(ResolveRecordRequest) returns (ResolveRecordResponse);
}
