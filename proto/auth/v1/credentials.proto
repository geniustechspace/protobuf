// Copyright 2024 GeniusTechSpace
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Authentication Credentials Message
//
// This file defines the Credentials message used for user authentication
// within a multi-tenant system. It encapsulates the required information
// for validating user identity before granting access.
//
// DOMAIN: Authentication
// CATEGORY: Security / Identity Management
// VERSION: v1
//
// COMPLIANCE:
// - SOC 2 CC6.1: Logical and physical access controls
// - SOC 2 CC6.6: Encryption of customer data at rest and in transit
// - ISO 27001 A.9.4.2: Secure log-on procedures
// - ISO 27001 A.9.4.3: Password management system
// - NIST 800-63B: Digital Identity Guidelines - Authentication
// - PCI DSS 8.2: User authentication for non-consumer users
//
// SECURITY:
// - Password transmitted only over TLS 1.2+ encrypted connections
// - Password never logged or stored in plaintext
// - Password hashed with bcrypt (cost factor 12) before storage
// - Rate limiting applied (5 attempts per 15 minutes per email/tenant)
// - Failed attempts logged for security monitoring
// - Account lockout after 5 consecutive failures
//
// AUDIT:
// - All authentication attempts logged with timestamp, IP, and result
// - Failed attempts trigger security monitoring alerts
// - Suspicious patterns (brute force) trigger automatic IP blocking
//
// PRIVACY:
// - Credentials not logged (password redacted in logs)
// - Email address encrypted in audit logs
// - Access logs retained for 90 days for security analysis
//
// VALIDATION:
// - Email: Must be valid RFC 5322 format
// - Password: Minimum 1 character (actual policy enforced server-side)
// - Tenant ID: Must be non-empty, valid tenant identifier

syntax = "proto3";

package auth.v1;

import "buf/validate/validate.proto";

option csharp_namespace = "GeniusTechSpace.Protobuf.Auth.V1";
option go_package = "github.com/geniustechspace/protobuf/gen/go/auth/v1;authv1";
option java_multiple_files = true;
option java_package = "com.geniustechspace.protobuf.auth.v1";

// Credentials encapsulates user authentication information.
//
// This message contains the essential information required to authenticate
// a user within a specific tenant. The credentials are validated against
// the tenant's user database with proper password hashing and security controls.
//
// SECURITY REQUIREMENTS:
// - Must be transmitted over TLS 1.2 or higher
// - Password field never logged or persisted in plaintext
// - Rate limiting enforced at API gateway level
// - Invalid credentials return generic error (no user enumeration)
//
// COMPLIANCE:
// - SOC 2 CC6.1: Implements logical access controls through authentication
// - ISO 27001 A.9.4.2: Secure log-on procedure with tenant isolation
// - NIST 800-63B Level 2: Password-based authentication
// - PCI DSS 8.2: Multi-factor authentication support (via device_id)
//
// VALIDATION RULES:
// - Email: Valid RFC 5322 email format (enforced by protovalidate)
// - Password: Non-empty (minimum length enforced at application layer)
// - Tenant ID: Non-empty string (enforces multi-tenant isolation)
//
// RATE LIMITING:
// - 5 attempts per 15 minutes per email/tenant combination
// - 10 attempts per 15 minutes per IP address
// - Exponential backoff after failed attempts
// - Account lockout after 5 consecutive failures within 1 hour
//
// AUDIT TRAIL:
// - Authentication attempt logged with timestamp
// - IP address and user agent recorded
// - Success/failure status tracked
// - Failed attempts trigger security monitoring
//
// ERROR HANDLING:
// - Invalid credentials: UNAUTHENTICATED (generic message)
// - Account locked: PERMISSION_DENIED with unlock instructions
// - Tenant not found: UNAUTHENTICATED (no tenant enumeration)
// - Rate limit exceeded: RESOURCE_EXHAUSTED with retry time
//
// EXAMPLE USAGE (Go):
//   credentials := &authv1.Credentials{
//       Email:     "user@example.com",
//       Password:  "SecurePassword123!",
//       TenantId:  "tenant_abc123",
//   }
//   response, err := authClient.Authenticate(ctx, &authv1.AuthenticateRequest{
//       Credentials: credentials,
//   })
//
// EXAMPLE USAGE (Python):
//   credentials = auth_pb2.Credentials(
//       email="user@example.com",
//       password="SecurePassword123!",
//       tenant_id="tenant_abc123"
//   )
//   response = auth_client.Authenticate(
//       auth_pb2.AuthenticateRequest(credentials=credentials)
//   )
message Credentials {
  // User's email address used as primary identifier.
  //
  // REQUIRED: Must be a valid email format per RFC 5322.
  // UNIQUE: Email must be unique within the tenant.
  // PII: Yes - Contains personally identifiable information.
  // ENCRYPTION: Encrypted in transit (TLS), may be encrypted at rest.
  //
  // VALIDATION:
  // - Format: RFC 5322 compliant email address
  // - Example: user@example.com
  // - Constraint: protovalidate email validation enforced
  //
  // SECURITY:
  // - Case-insensitive comparison during authentication
  // - Normalized to lowercase before storage/comparison
  // - Not disclosed in error messages (prevents user enumeration)
  //
  // COMPLIANCE:
  // - GDPR Article 4(1): Personal data - direct identifier
  // - CCPA: Personal information requiring protection
  //
  // ERROR CONDITIONS:
  // - Empty: INVALID_ARGUMENT "email is required"
  // - Invalid format: INVALID_ARGUMENT "invalid email format"
  // - Not found: UNAUTHENTICATED (generic message)
  string email = 1 [(buf.validate.field).string.email = true];

  // User's password for authentication.
  //
  // REQUIRED: Must be non-empty (minimum length policy enforced server-side).
  // SENSITIVE: Never logged, never stored in plaintext.
  // HASHING: bcrypt with cost factor 12 before storage.
  //
  // PASSWORD POLICY (enforced server-side):
  // - Minimum length: 8 characters
  // - Must contain: uppercase, lowercase, number, special character
  // - Cannot be common password (checked against breach database)
  // - Cannot reuse last 5 passwords
  // - Expires after 90 days (configurable per tenant)
  //
  // VALIDATION:
  // - Minimum 1 character (client-side validation)
  // - Full password policy checked server-side
  //
  // SECURITY:
  // - Transmitted only over TLS 1.2+
  // - Never logged (redacted in all log entries)
  // - Never included in error messages
  // - Hashed immediately upon receipt
  // - Original value securely wiped from memory
  //
  // COMPLIANCE:
  // - NIST 800-63B: Memorized secret authenticator requirements
  // - SOC 2 CC6.1: Strong password requirements
  // - ISO 27001 A.9.4.3: Password management system
  // - PCI DSS 8.2.3: Strong password requirements
  //
  // ERROR CONDITIONS:
  // - Empty: INVALID_ARGUMENT "password is required"
  // - Incorrect: UNAUTHENTICATED (generic message, no indication)
  // - Expired: PERMISSION_DENIED "password expired, reset required"
  string password = 2 [(buf.validate.field).string.min_len = 1];

  // Tenant identifier for multi-tenant isolation.
  //
  // REQUIRED: Must be non-empty string.
  // PURPOSE: Ensures authentication occurs within correct tenant context.
  // ISOLATION: Critical for proper data segregation.
  //
  // VALIDATION:
  // - Must be non-empty
  // - Must reference existing, active tenant
  // - Format: Alphanumeric with underscores (tenant_*)
  //
  // SECURITY:
  // - Prevents cross-tenant authentication
  // - Validated before password hash lookup
  // - Invalid tenant returns generic auth failure (no enumeration)
  //
  // COMPLIANCE:
  // - SOC 2 CC6.1: Logical access controls via tenant separation
  // - ISO 27001 A.9.4.1: Access control policy - tenant isolation
  //
  // MULTI-TENANCY:
  // - Same email can exist in different tenants
  // - Authentication scoped to tenant_id + email combination
  // - User permissions isolated per tenant
  //
  // ERROR CONDITIONS:
  // - Empty: INVALID_ARGUMENT "tenant_id is required"
  // - Not found: UNAUTHENTICATED (generic message)
  // - Suspended: PERMISSION_DENIED "tenant account suspended"
  // - Deleted: UNAUTHENTICATED (generic message)
  string tenant_id = 3 [(buf.validate.field).string.min_len = 1];
}
