// Access Policy Domain - Role-Based Access Control (RBAC)
//
// Defines roles, permissions, and conditional policies for fine-grained
// access control in multi-tenant environments with attribute-based evaluation.
//
// COMPLIANCE: SOC 2 CC6.1 (Logical access controls), SOC 2 CC6.2 (Access management)
//             ISO 27001 A.9.2 (User access management), ISO 27001 A.9.4 (Access control)
//             NIST SP 800-53 AC-2 (Account Management), AC-3 (Access Enforcement)
// SECURITY: Principle of least privilege enforced. All operations audited.
//           Tenant isolation strictly enforced in all policy evaluations.

syntax = "proto3";

package access_policy.v1;

import "core/v1/common.proto";

option csharp_namespace = "GeniusTechSpace.Protobuf.AccessPolicy.V1";
option go_package = "github.com/geniustechspace/protobuf/gen/go/access_policy/v1;accesspolicyv1";
option java_multiple_files = true;
option java_package = "com.geniustechspace.protobuf.accesspolicy.v1";

// Permission represents a granular action that can be performed on a resource.
//
// COMPLIANCE: SOC 2 CC6.1 (Permission granularity), ISO 27001 A.9.2.3
message Permission {
  // Unique permission identifier
  string id = 1;

  // Human-readable permission name (e.g., "user:create", "billing:read")
  string name = 2;

  // Resource type this permission applies to (e.g., "users", "subscriptions")
  string resource = 3;

  // Action being permitted (e.g., "create", "read", "update", "delete")
  string action = 4;

  // Permission description for documentation
  string description = 5;
}

// Role represents a collection of permissions assigned as a unit.
//
// COMPLIANCE: SOC 2 CC6.1 (Role definition), ISO 27001 A.9.2.1 (User registration)
message Role {
  // Standard metadata (ID, timestamps, created_by, etc.)
  core.v1.Metadata metadata = 1;

  // Tenant ID for isolation. REQUIRED
  string tenant_id = 2;

  // Role name (e.g., "admin", "editor", "viewer"). REQUIRED, unique per tenant
  string name = 3;

  // Role description for documentation
  string description = 4;

  // Permissions granted by this role
  repeated Permission permissions = 5;

  // System-defined role (cannot be modified/deleted)
  bool is_system_role = 6;
}

// Policy defines conditional access rules with attribute-based evaluation.
//
// COMPLIANCE: SOC 2 CC6.1 (Dynamic access control), NIST SP 800-162 (ABAC)
message Policy {
  // Standard metadata (ID, timestamps, created_by, etc.)
  core.v1.Metadata metadata = 1;

  // Tenant ID for isolation. REQUIRED
  string tenant_id = 2;

  // Policy name. REQUIRED, unique per tenant
  string name = 3;

  // Policy description
  string description = 4;

  // Access rules defining conditions
  repeated PolicyRule rules = 5;

  // Effect to apply when rules match (allow/deny)
  PolicyEffect effect = 6;
}

// PolicyRule defines resource/action combinations with conditional evaluation.
message PolicyRule {
  // Resource pattern (e.g., "users/*", "billing/subscriptions/*")
  string resource = 1;

  // Actions permitted on resource (e.g., ["read", "update"])
  repeated string actions = 2;

  // Conditions that must be satisfied for rule to apply
  repeated Condition conditions = 3;
}

// Condition represents an attribute-based condition for policy evaluation.
message Condition {
  // Condition key (e.g., "user.department", "time.hour", "ip.address")
  string key = 1;

  // Comparison operator
  ConditionOperator operator = 2;

  // Values to compare against
  repeated string values = 3;
}

// ConditionOperator defines comparison operators for condition evaluation.
enum ConditionOperator {
  CONDITION_OPERATOR_UNSPECIFIED = 0;
  CONDITION_OPERATOR_EQUALS = 1; // Exact match
  CONDITION_OPERATOR_NOT_EQUALS = 2; // Not equal
  CONDITION_OPERATOR_IN = 3; // In list
  CONDITION_OPERATOR_NOT_IN = 4; // Not in list
  CONDITION_OPERATOR_CONTAINS = 5; // Contains substring
  CONDITION_OPERATOR_NOT_CONTAINS = 6; // Does not contain
}

// PolicyEffect determines whether access is allowed or denied.
//
// COMPLIANCE: Explicit deny overrides allow (default deny)
enum PolicyEffect {
  POLICY_EFFECT_UNSPECIFIED = 0;
  POLICY_EFFECT_ALLOW = 1; // Grant access
  POLICY_EFFECT_DENY = 2; // Deny access (takes precedence)
}

// CreateRoleRequest for creating a new role
message CreateRoleRequest {
  string tenant_id = 1;
  string name = 2;
  string description = 3;
  repeated Permission permissions = 4;
}

// CreateRoleResponse returns the created role
message CreateRoleResponse {
  Role role = 1;
}

// GetRoleRequest for retrieving a role
message GetRoleRequest {
  string tenant_id = 1;
  string role_id = 2;
}

// GetRoleResponse returns the requested role
message GetRoleResponse {
  Role role = 1;
}

// UpdateRoleRequest for updating a role
message UpdateRoleRequest {
  string tenant_id = 1;
  string role_id = 2;
  string name = 3;
  string description = 4;
  repeated Permission permissions = 5;
}

// UpdateRoleResponse returns the updated role
message UpdateRoleResponse {
  Role role = 1;
}

// DeleteRoleRequest for deleting a role
message DeleteRoleRequest {
  string tenant_id = 1;
  string role_id = 2;
}

// DeleteRoleResponse confirms deletion
message DeleteRoleResponse {
  bool success = 1;
}

// ListRolesRequest for listing roles
message ListRolesRequest {
  string tenant_id = 1;
  core.v1.PaginationRequest pagination = 2;
}

// ListRolesResponse returns a list of roles
message ListRolesResponse {
  repeated Role roles = 1;
  core.v1.PaginationResponse pagination = 2;
}

// AssignRoleRequest for assigning a role to a user
message AssignRoleRequest {
  string tenant_id = 1;
  string user_id = 2;
  string role_id = 3;
}

// AssignRoleResponse confirms role assignment
message AssignRoleResponse {
  bool success = 1;
}

// RevokeRoleRequest for revoking a role from a user
message RevokeRoleRequest {
  string tenant_id = 1;
  string user_id = 2;
  string role_id = 3;
}

// RevokeRoleResponse confirms role revocation
message RevokeRoleResponse {
  bool success = 1;
}

// CheckPermissionRequest for checking if a user has permission
message CheckPermissionRequest {
  string tenant_id = 1;
  string user_id = 2;
  string resource = 3;
  string action = 4;
  map<string, string> context = 5;
}

// CheckPermissionResponse returns the permission check result
message CheckPermissionResponse {
  bool allowed = 1;
  string reason = 2;
}

// AccessPolicyService provides role-based and attribute-based access control.
//
// COMPLIANCE: SOC 2 CC6.1, CC6.2 (Access controls), ISO 27001 A.9.2, A.9.4
// AUTHENTICATION: All RPCs require valid authentication token
// AUTHORIZATION: Requires 'access_policy:admin' permission
// AUDIT: All operations logged with user, timestamp, and changes
service AccessPolicyService {
  // CreateRole creates a new role with permissions. Requires 'access_policy:admin'.
  // COMPLIANCE: SOC 2 CC6.1 (Role creation)
  rpc CreateRole(CreateRoleRequest) returns (CreateRoleResponse);

  // GetRole retrieves role details. Requires 'access_policy:read'.
  rpc GetRole(GetRoleRequest) returns (GetRoleResponse);

  // UpdateRole modifies role permissions. Requires 'access_policy:admin'.
  // COMPLIANCE: SOC 2 CC6.3 (Change management)
  rpc UpdateRole(UpdateRoleRequest) returns (UpdateRoleResponse);

  // DeleteRole removes a role. System roles cannot be deleted. Requires 'access_policy:admin'.
  // COMPLIANCE: SOC 2 CC6.2 (Access termination)
  rpc DeleteRole(DeleteRoleRequest) returns (DeleteRoleResponse);

  // ListRoles lists all roles for a tenant. Requires 'access_policy:read'.
  rpc ListRoles(ListRolesRequest) returns (ListRolesResponse);

  // AssignRole grants role to user. Requires 'access_policy:admin'.
  // COMPLIANCE: SOC 2 CC6.1 (User provisioning)
  rpc AssignRole(AssignRoleRequest) returns (AssignRoleResponse);

  // RevokeRole removes role from user. Requires 'access_policy:admin'.
  // COMPLIANCE: SOC 2 CC6.2 (Access revocation)
  rpc RevokeRole(RevokeRoleRequest) returns (RevokeRoleResponse);

  // CheckPermission evaluates if user has permission with context. High-frequency operation.
  // PERFORMANCE: Cached for 5 minutes. Rate limit: 1000 req/sec per user
  rpc CheckPermission(CheckPermissionRequest) returns (CheckPermissionResponse);
}
