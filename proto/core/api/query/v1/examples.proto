// Core API Query - Usage Examples
//
// Comprehensive examples for common query patterns.

syntax = "proto3";

package geniustechspace.core.api.query.v1;

import "core/api/query/v1/query.proto";

option go_package = "github.com/geniustechspace/protobuf/gen/go/core/api/query/v1;queryv1";

// Example patterns for building queries.
// These messages are documentation-only (never instantiated).
message Examples {
  // ==================== BASIC PATTERNS ====================

  // Simple equality filter
  // Query{filter: {field: "status", op: EQ, value: "active"}}

  // Multiple AND conditions
  // Query{filter: {and: [
  //   {field: "status", op: EQ, value: "active"},
  //   {field: "tier", op: EQ, value: "premium"}
  // ]}}

  // OR conditions
  // Query{filter: {or: [
  //   {field: "role", op: EQ, value: "admin"},
  //   {field: "role", op: EQ, value: "owner"}
  // ]}}

  // Complex AND/OR
  // Query{filter: {and: [
  //   {field: "status", op: EQ, value: "active"},
  //   {or: [
  //     {field: "tier", op: EQ, value: "premium"},
  //     {field: "tier", op: EQ, value: "enterprise"}
  //   ]}
  // ]}}

  // Negation (via NE)
  // Query{filter: {field: "status", op: NE, value: "deleted"}}

  // ==================== RANGE QUERIES ====================

  // Date range
  // Query{filter: {and: [
  //   {field: "created_at", op: GTE, value: "2024-01-01"},
  //   {field: "created_at", op: LT, value: "2024-02-01"}
  // ]}}

  // BETWEEN (two values)
  // Query{filter: {
  //   field: "price",
  //   op: BETWEEN,
  //   values: ["50", "200"]
  // }}

  // ==================== STRING MATCHING ====================

  // Contains substring
  // Query{filter: {
  //   field: "email",
  //   op: CONTAINS,
  //   value: "@gmail.com"
  // }}

  // Starts with
  // Query{filter: {
  //   field: "name",
  //   op: STARTS_WITH,
  //   value: "John"
  // }}

  // Case-insensitive like
  // Query{filter: {
  //   field: "description",
  //   op: ILIKE,
  //   value: "%search term%"
  // }}

  // Regex match
  // Query{filter: {
  //   field: "phone",
  //   op: MATCHES,
  //   value: "^\\+1[0-9]{10}$"
  // }}

  // ==================== IN QUERIES ====================

  // IN list
  // Query{filter: {
  //   field: "status",
  //   op: IN,
  //   values: ["active", "pending", "approved"]
  // }}

  // NOT IN
  // Query{filter: {
  //   field: "role",
  //   op: NOT_IN,
  //   values: ["blocked", "suspended"]
  // }}

  // ==================== NULL CHECKS ====================

  // Is NULL
  // Query{filter: {
  //   field: "deleted_at",
  //   op: IS_NULL
  // }}

  // Is NOT NULL
  // Query{filter: {
  //   field: "verified_at",
  //   op: IS_NOT_NULL
  // }}

  // ==================== ARRAY OPERATIONS ====================

  // Array contains value
  // Query{filter: {
  //   field: "tags",
  //   op: ARRAY_CONTAINS,
  //   value: "featured"
  // }}

  // Array contains any
  // Query{filter: {
  //   field: "permissions",
  //   op: ARRAY_CONTAINS_ANY,
  //   values: ["read", "write", "admin"]
  // }}

  // Array contains all
  // Query{filter: {
  //   field: "skills",
  //   op: ARRAY_CONTAINS_ALL,
  //   values: ["python", "docker", "kubernetes"]
  // }}

  // ==================== SORTING ====================

  // Simple sort
  // Query{
  //   filter: {field: "status", op: EQ, value: "active"},
  //   sorts: [{field: "created_at", direction: DESC}]
  // }

  // Multi-field sort
  // Query{sorts: [
  //   {field: "priority", direction: DESC},
  //   {field: "created_at", direction: ASC}
  // ]}

  // Sort with null handling
  // Query{sorts: [{
  //   field: "completed_at",
  //   direction: ASC,
  //   null_handling: NULLS_LAST
  // }]}

  // ==================== PROJECTION (PSL v1) ====================

  // Select specific fields (include-only mode)
  // Query{include: ["id", "email", "name"]}

  // Exclude secrets (exclude-only mode: include all except)
  // Query{exclude: ["password", "passwordHash", "token", "ssn"]}

  // Include subtree, exclude one
  // Query{
  //   include: ["user.**"],
  //   exclude: ["user.password"]
  // }

  // List elements with specific fields
  // Query{include: ["orders[].id", "orders[].total", "orders[].status"]}

  // All map values
  // Query{include: ["attributes[*]", "metadata[*].value"]}

  // Deep wildcard: all IDs everywhere
  // Query{include: ["**.id", "**.createdAt"]}

  // Single-level wildcard
  // Query{include: ["user.*", "profile.*"]}

  // ==================== FULL-TEXT SEARCH ====================

  // Natural language search
  // Query{search: {
  //   query: "machine learning tutorial",
  //   fields: ["title", "description"],
  //   options: {mode: NATURAL}
  // }}

  // Universal search (all text fields)
  // Query{search: {
  //   query: "error",
  //   fields: ["**"],  // Searches all text fields
  //   options: {mode: NATURAL}
  // }}

  // Search with wildcard patterns
  // Query{search: {
  //   query: "configuration",
  //   fields: ["logs.*", "**.description"],  // Pattern matching
  //   options: {mode: NATURAL}
  // }}

  // Fuzzy search
  // Query{search: {
  //   query: "pythn",
  //   fields: ["tags"],
  //   options: {mode: FUZZY, fuzziness: 2}
  // }}

  // Phrase match
  // Query{search: {
  //   query: "artificial intelligence",
  //   options: {mode: PHRASE}
  // }}

  // With field boosting
  // Query{search: {
  //   query: "kubernetes",
  //   fields: ["title", "description"],
  //   options: {
  //     mode: NATURAL,
  //     field_boosts: {"title": 2.0, "description": 1.0}
  //   }
  // }}

  // ==================== AGGREGATION ====================

  // Count by group
  // Query{grouping: {
  //   fields: ["status"],
  //   aggregates: [{function: COUNT, alias: "count"}]
  // }}

  // Multiple aggregations
  // Query{grouping: {
  //   fields: ["category"],
  //   aggregates: [
  //     {function: COUNT, alias: "total"},
  //     {function: SUM, field: "amount", alias: "revenue"},
  //     {function: AVG, field: "rating", alias: "avg_rating"}
  //   ]
  // }}

  // With HAVING filter
  // Query{grouping: {
  //   fields: ["user_id"],
  //   aggregates: [{function: COUNT, alias: "order_count"}],
  //   having: "order_count > 5"
  // }}

  // ==================== GEOSPATIAL ====================

  // Near location (lat, lng, radius_km as separate values)
  // Query{filter: {
  //   field: "location",
  //   op: GEO_NEAR,
  //   values: ["40.7128", "-74.0060", "10"]
  // }}

  // Within area (bounding box as single value)
  // Query{filter: {
  //   field: "location",
  //   op: GEO_WITHIN,
  //   value: "[[40.7128,-74.0060],[40.7580,-73.9855]]"
  // }}

  // ==================== RELATIONS (AUTO-INFERENCE) ====================

  // Relations auto-detected from include paths
  // Query{
  //   filter: {field: "id", op: EQ, value: "123"},
  //   include: ["id", "user.name", "comments[].content"]
  //   // Server auto-loads "user" and "comments" relations
  // }

  // Nested relations (dot notation auto-infers chain)
  // Query{
  //   filter: {field: "id", op: EQ, value: "123"},
  //   include: [
  //     "id",
  //     "user.name",
  //     "user.profile.city",
  //     "user.organization.name",
  //     "user.organization.billing.plan"
  //   ]
  //   // Auto-loads: user → user.profile → user.organization → user.organization.billing
  // }

  // Load entire relation subtree (wildcard)
  // Query{
  //   filter: {field: "id", op: EQ, value: "123"},
  //   include: ["id", "user.**"]  // Auto-loads all nested user relations
  // }

  // Load specific nested relations from lists
  // Query{
  //   filter: {field: "id", op: EQ, value: "123"},
  //   include: [
  //     "id",
  //     "comments[].author.name",
  //     "comments[].reactions",
  //     "orders[].items.product.name"
  //   ]
  //   // Auto-loads: comments → comments.author, comments.reactions,
  //   //             orders → orders.items → orders.items.product
  // }

  // Load all metadata relations recursively
  // Query{
  //   filter: {field: "id", op: EQ, value: "123"},
  //   include: ["id", "**.metadata"]  // Deep wildcard - loads all metadata
  // }

  // Relations with filters (use dot notation in filter)
  // Query{
  //   filter: {and: [
  //     {field: "id", op: EQ, value: "123"},
  //     {field: "comments.approved", op: EQ, value: "true"}
  //   ]},
  //   include: ["id", "comments.content", "comments.author.name"]
  //   // Filter + include both detect "comments" relation
  // }

  // ==================== COMPLEX EXAMPLES ====================

  // E-commerce product search
  // Query{
  //   search: {
  //     query: "wireless headphones",
  //     fields: ["name", "description"],
  //     options: {mode: FUZZY, fuzziness: 1}
  //   },
  //   filter: {and: [
  //     {field: "price", op: BETWEEN, values: ["50", "200"]},
  //     {field: "in_stock", op: EQ, value: "true"},
  //     {field: "rating", op: GTE, value: "4.0"}
  //   ]},
  //   sorts: [
  //     {field: "popularity", direction: DESC},
  //     {field: "price", direction: ASC}
  //   ],
  //   include: ["id", "name", "price", "image_url"],
  //   pagination: {page_size: 20}
  // }

  // Analytics dashboard
  // Query{
  //   filter: {
  //     field: "created_at",
  //     op: GTE,
  //     value: "2024-01-01"
  //   },
  //   grouping: {
  //     fields: ["status", "category"],
  //     aggregates: [
  //       {function: COUNT, alias: "total"},
  //       {function: SUM, field: "revenue", alias: "revenue"},
  //       {function: AVG, field: "amount", alias: "avg"}
  //     ]
  //   }
  // }

  // Multi-tenant with relations (auto-inference)
  // Query{
  //   filter: {and: [
  //     {field: "tenant_id", op: EQ, value: "tenant_123"},
  //     {field: "deleted_at", op: IS_NULL},
  //     {or: [
  //       {field: "status", op: EQ, value: "active"},
  //       {field: "status", op: EQ, value: "pending"}
  //     ]}
  //   ]},
  //   include: [
  //     "id", "name", "status",
  //     "created_by.name",
  //     "organization.name",
  //     "organization.billing.plan",
  //     "organization.subscription.tier"
  //   ],
  //   // Server auto-loads: created_by, organization, organization.billing,
  //   //                    organization.subscription
  //   sorts: [{field: "created_at", direction: DESC}],
  //   pagination: {page_size: 50}
  // }
}
