// Core API Query - Main Query Module
//
// Unified query interface for all storage systems.
// Simple queries use 1-2 fields, complex queries combine multiple features.

syntax = "proto3";

package geniustechspace.core.api.query.v1;

import "buf/validate/validate.proto";
import "core/api/pagination/v1/messages.proto";
import "core/api/query/v1/aggregation.proto";
import "core/api/query/v1/filter.proto";
import "core/api/query/v1/relation.proto";
import "core/api/query/v1/search.proto";
import "core/api/query/v1/sort.proto";

option go_package = "github.com/geniustechspace/protobuf/gen/go/core/api/query/v1;queryv1";
option java_multiple_files = true;
option java_package = "com.geniustechspace.protobuf.core.api.query.v1";

// Query is the unified query interface.
// Start simple, add complexity as needed.
//
// DESIGN PHILOSOPHY:
// - Filter supports dot notation for relations: "user.status" auto-joins user
// - Include/exclude patterns infer relations: "user.name" auto-loads user
// - Server detects needed joins from filter and projection paths
// - Keep explicit Join for rare complex cases
//
// SIMPLE: {filter: {field: "status", op: EQ, value: "active"}}
// RELATIONS: {filter: {field: "user.email", op: CONTAINS, value: "@company.com"}}
// PROJECTION: {include: ["id", "user.name", "user.email"]}
message Query {
  // Filter results. Supports dot notation for relations.
  // Values are type-safe: use 'value' for scalars, 'values' for lists.
  // Examples:
  //   {field: "status", op: EQ, value: "active"}  // Scalar
  //   {field: "user.status", op: EQ, value: "verified"}  // Auto-join user
  //   {field: "orders[].total", op: GT, value: "100"}  // List relation
  //   {field: "role", op: IN, values: ["admin", "owner"]}  // List
  Filter filter = 1;

  // Sorting/ordering results. Can reference relation fields.
  // Example: [{field: "user.created_at", direction: DESC}]
  repeated Sorting sorts = 2 [(buf.validate.field).repeated.max_items = 10];

  // Field patterns to include (PSL v1 syntax).
  // Empty = include all (then apply exclude).
  // Server auto-detects and loads relations from paths.
  //
  // EXAMPLES:
  //   ["id", "name", "email"]  // Simple fields
  //   ["user.**"]  // Entire user relation subtree (auto-load user)
  //   ["user.name", "user.email"]  // Specific user fields (auto-load user)
  //   ["orders[].id", "orders[].total"]  // List relation (auto-load orders)
  //   ["**.id"]  // All IDs recursively
  //
  // Relations are inferred - no need to specify separately!
  repeated string include = 3 [(buf.validate.field).repeated = {
    max_items: 200
    items: {
      string: {
        min_len: 1
        max_len: 500
        pattern: "^[A-Za-z_][A-Za-z0-9_.\\[\\]\\*`']*$"
      }
    }
  }];

  // Field patterns to exclude. Applied after include.
  // Use for security: exclude: ["**.password", "**.token"]
  repeated string exclude = 4 [(buf.validate.field).repeated = {
    max_items: 200
    items: {
      string: {
        min_len: 1
        max_len: 500
        pattern: "^[A-Za-z_][A-Za-z0-9_.\\[\\]\\*`']*$"
      }
    }
  }];

  // Pagination
  geniustechspace.core.api.pagination.v1.PaginationRequest pagination = 5;

  // Full-text search
  Search search = 6;

  // Aggregation and grouping
  Grouping grouping = 7;

  // Explicit joins (rare - most cases use filter + include for auto-join).
  // Use when you need fine control over join type, conditions, or aliases.
  repeated Join joins = 8 [(buf.validate.field).repeated.max_items = 10];

  // Query timeout (milliseconds)
  int64 timeout_ms = 9 [(buf.validate.field).int64 = {
    gte: 0
    lte: 300000
  }];

  // Include soft-deleted entities
  bool include_deleted = 10;

  // Explain query execution (debugging)
  bool explain = 11;

  // Query options (storage-specific)
  map<string, string> options = 12 [(buf.validate.field).map.max_pairs = 20];
}

// QueryBuilder provides fluent query construction hints.
// This is documentation-only; actual builders generated in SDKs.
//
// EXAMPLES:
//
// Simple filter:
//   Query{filter: {field: "status", op: EQ, value: {string: "active"}}}
//
// Filter + Projection:
//   Query{
//     filter: {field: "status", op: EQ, value: {string: "active"}},
//     include: ["id", "name", "email"]
//   }
//
// Auto-join with relations:
//   Query{
//     filter: {field: "user.status", op: EQ, value: {string: "verified"}},
//     include: ["id", "name", "user.email"]
//   }
//   // Server detects "user" relation from filter and include paths
//
// Complex AND/OR with relations:
//   Query{filter: {and: [
//     {field: "status", op: EQ, value: {string: "active"}},
//     {field: "user.email", op: CONTAINS, value: {string: "@company.com"}},
//     {or: [
//       {field: "tier", op: EQ, value: {string: "premium"}},
//       {field: "tier", op: EQ, value: {string: "enterprise"}}
//     ]}
//   ]}}
//
// Exclude sensitive fields:
//   Query{
//     include: ["user.**"],
//     exclude: ["**.password", "**.token", "**.ssn"]
//   }
//
// Full-text search:
//   Query{search: {
//     query: "machine learning",
//     fields: ["title", "description"],
//     options: {mode: SEMANTIC, min_score: 0.7}
//   }}
//
// Aggregation:
//   Query{grouping: {
//     fields: ["status"],
//     aggregates: [{function: COUNT, alias: "count"}]
//   }}
//
// List relations:
//   Query{
//     filter: {field: "orders[].total", op: GT, value: {string: "100"}},
//     include: ["id", "orders[].id", "orders[].total"]
//   }
message QueryBuilder {}
