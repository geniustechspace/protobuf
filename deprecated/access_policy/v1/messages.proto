// Access Policy Domain - Core Messages
//
// Defines roles, permissions, policies, and conditions for fine-grained
// role-based and attribute-based access control in multi-tenant environments.
//
// PURPOSE: Enable enterprise-grade access control with RBAC and ABAC support
// COMPLIANCE: SOC 2 CC6.1, CC6.2 (Access controls), ISO 27001 A.9.2, A.9.4
//             NIST SP 800-53 AC-2 (Account Management), AC-3 (Access Enforcement)
// SECURITY: Principle of least privilege enforced. All operations audited.
//           Tenant isolation strictly enforced in all policy evaluations.

syntax = "proto3";

package access_policy.v1;

import "core/v1/metadata.proto";
import "access_policy/v1/enums.proto";

option csharp_namespace = "GeniusTechSpace.Protobuf.AccessPolicy.V1";
option go_package = "github.com/geniustechspace/protobuf/gen/go/access_policy/v1;accesspolicyv1";
option java_multiple_files = true;
option java_package = "com.geniustechspace.protobuf.accesspolicy.v1";

// Permission represents a granular action that can be performed on a resource.
//
// PURPOSE: Atomic unit of authorization - defines what can be done to what
// COMPLIANCE: SOC 2 CC6.1 (Permission granularity), ISO 27001 A.9.2.3
// BEST PRACTICE: Follow "resource:action" naming convention for consistency
//
// NAMING CONVENTION: {resource}:{action}
//   Examples: "users:create", "billing:read", "tenants:delete"
//
// DESIGN: Permissions are stateless, reusable, and composable into roles
message Permission {
  // Unique permission identifier. REQUIRED, immutable.
  // FORMAT: UUID v4 or human-readable ID
  // Example: "perm_01HQZX5J8K9M3N4P5Q6R7S8T9V"
  string id = 1;

  // Human-readable permission name. REQUIRED, unique across system.
  // CONVENTION: "{resource}:{action}" format for consistency
  // Examples: "user:create", "billing:read", "tenant:delete", "role:assign"
  // VALIDATION: Should match pattern "^[a-z_]+:[a-z_]+$"
  string name = 2;

  // Resource type this permission applies to. REQUIRED.
  // PURPOSE: Groups permissions by resource for RBAC management
  // Examples: "users", "subscriptions", "invoices", "roles", "tenants"
  // CONVENTION: Plural noun, lowercase
  string resource = 3;

  // Action being permitted. REQUIRED.
  // PURPOSE: Defines the operation allowed on the resource
  // COMMON ACTIONS: "create", "read", "update", "delete", "list", "assign", "revoke"
  // CONVENTION: Verb, lowercase
  string action = 4;

  // Permission description for documentation and UI display. RECOMMENDED.
  // PURPOSE: Help administrators understand permission purpose when assigning roles
  // Example: "Create new user accounts within the tenant"
  string description = 5;
}

// Role represents a named collection of permissions assigned as a unit.
//
// PURPOSE: Simplify access management by grouping permissions into job functions
// COMPLIANCE: SOC 2 CC6.1 (Role definition), ISO 27001 A.9.2.1 (User registration)
// PATTERN: Role-Based Access Control (RBAC) - industry standard authorization model
//
// ROLE HIERARCHY EXAMPLE:
//   Viewer: read-only permissions
//   Editor: Viewer + create/update permissions
//   Admin: Editor + delete + manage permissions
//   Owner: Admin + tenant management
message Role {
  // Standard metadata (ID, timestamps, created_by, etc.). REQUIRED.
  // PURPOSE: Audit trail and version control for role changes
  core.v1.Metadata metadata = 1;

  // Tenant ID for multi-tenant isolation. REQUIRED, immutable.
  // COMPLIANCE: SOC 2 CC6.1 - Ensures roles cannot be used cross-tenant
  // VALIDATION: Must match authenticated user's tenant
  string tenant_id = 2;

  // Role name. REQUIRED, unique per tenant.
  // PURPOSE: Human-readable identifier displayed in UI and logs
  // CONVENTION: Title Case (e.g., "Admin", "Billing Manager", "Viewer")
  // VALIDATION: 1-100 characters, alphanumeric with spaces/hyphens
  // Examples: "Admin", "Billing Manager", "Read-Only Viewer", "Support Agent"
  string name = 3;

  // Role description for documentation. RECOMMENDED.
  // PURPOSE: Explain role purpose and typical use cases
  // Example: "Full administrative access including user management and billing"
  string description = 4;

  // Permissions granted by this role. REQUIRED, at least one permission.
  // PURPOSE: Defines what users with this role are allowed to do
  // BEHAVIOR: Users inherit ALL permissions from ALL assigned roles
  // BEST PRACTICE: Assign minimal permissions needed for job function (least privilege)
  repeated Permission permissions = 5;

  // System-defined role flag. Immutable roles managed by platform.
  // PURPOSE: Prevent modification/deletion of critical predefined roles
  // BEHAVIOR: When true, role cannot be modified or deleted via API
  // EXAMPLES: "Owner", "Admin", "Member" - platform-defined roles
  // DEFAULT: false (user-defined roles)
  bool is_system_role = 6;
}

// Policy defines conditional access rules with attribute-based evaluation.
//
// PURPOSE: Advanced access control beyond simple RBAC using runtime attributes
// COMPLIANCE: SOC 2 CC6.1 (Dynamic access control), NIST SP 800-162 (ABAC)
// PATTERN: Attribute-Based Access Control (ABAC) - context-aware authorization
//
// USE CASES:
//   - Time-based access: Allow access only during business hours
//   - Location-based: Deny access from non-corporate IP ranges
//   - Conditional permissions: Allow invoice:read only for own department
//   - Break-glass: Allow emergency access with logging
message Policy {
  // Standard metadata (ID, timestamps, created_by, etc.). REQUIRED.
  core.v1.Metadata metadata = 1;

  // Tenant ID for isolation. REQUIRED, immutable.
  // COMPLIANCE: SOC 2 CC6.1 - Policies scoped to single tenant
  string tenant_id = 2;

  // Policy name. REQUIRED, unique per tenant.
  // PURPOSE: Human-readable identifier for policy management
  // Examples: "Business Hours Only", "Corporate IP Only", "Department Isolation"
  string name = 3;

  // Policy description explaining purpose and conditions. RECOMMENDED.
  // Example: "Restrict billing access to corporate IP ranges during business hours"
  string description = 4;

  // Access rules defining resource/action/condition combinations. REQUIRED.
  // PURPOSE: Specific rules evaluated when policy is checked
  // EVALUATION: ALL rules must match for policy to apply (AND logic)
  repeated PolicyRule rules = 5;

  // Effect to apply when all rules match. REQUIRED.
  // PURPOSE: Determine if matching policy grants or denies access
  // SECURITY: DENY policies take precedence over ALLOW policies
  PolicyEffect effect = 6;
}

// PolicyRule defines resource/action patterns with conditional evaluation.
//
// PURPOSE: Granular rule within a policy specifying what/when access is controlled
// EVALUATION: All conditions within a rule must be true for rule to match (AND logic)
message PolicyRule {
  // Resource pattern using wildcard matching. REQUIRED.
  // PURPOSE: Define which resources this rule applies to
  // PATTERNS:
  //   Exact: "users/user_123" - specific resource
  //   Wildcard: "users/*" - all users
  //   Prefix: "billing/invoices/*" - all invoices
  // Examples: "users/*", "billing/subscriptions/*", "tenants/tenant_456"
  string resource = 1;

  // Actions permitted on matched resources. REQUIRED, at least one.
  // PURPOSE: Define which operations are controlled by this rule
  // Examples: ["read"], ["read", "update"], ["*"] (all actions)
  repeated string actions = 2;

  // Conditions that must be satisfied for rule to apply. Optional.
  // PURPOSE: Add contextual/attribute-based checks to access decisions
  // EVALUATION: ALL conditions must evaluate to true (AND logic)
  // COMMON ATTRIBUTES: "time.hour", "user.department", "ip.address", "user.role"
  repeated Condition conditions = 3;
}

// Condition represents an attribute-based condition for policy evaluation.
//
// PURPOSE: Runtime check using request context and user attributes
// PATTERN: Subject-Operator-Value triple for condition evaluation
// EXAMPLES:
//   user.department EQUALS "Finance"
//   time.hour IN ["9", "10", "11", "12", "13", "14", "15", "16", "17"]
//   ip.address CONTAINS "10.0."
message Condition {
  // Condition key - attribute path to evaluate. REQUIRED.
  // PURPOSE: Specify which attribute to check in evaluation context
  // CONVENTION: dot-notation for nested attributes
  // COMMON KEYS:
  //   User attributes: "user.id", "user.email", "user.department", "user.roles"
  //   Time attributes: "time.hour", "time.day_of_week", "time.date"
  //   Request attributes: "ip.address", "request.path", "request.method"
  // Examples: "user.department", "time.hour", "ip.address"
  string key = 1;

  // Comparison operator for condition evaluation. REQUIRED.
  // PURPOSE: Define how key value is compared against condition values
  // SEE: ConditionOperator enum for available operators
  ConditionOperator operator = 2;

  // Values to compare against using specified operator. REQUIRED, at least one.
  // PURPOSE: Expected values for condition to match
  // FORMAT: Always string array, type coercion performed during evaluation
  // Examples: ["Finance", "Engineering"], ["9", "17"], ["10.0.0"]
  repeated string values = 3;
}
