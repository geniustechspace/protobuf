// IDP Security Policies - Version 1
// Enterprise security controls for authentication and authorization
//
// COMPLIANCE:
//   - NIST 800-63B (Password requirements)
//   - OWASP (Rate limiting, account lockout)
//   - PCI DSS 3.2.1 (Password complexity)
//   - SOC 2 (Security controls)
//
// PURPOSE:
//   - Password policy enforcement
//   - Rate limiting configuration
//   - Account lockout rules
//   - Risk-based authentication

syntax = "proto3";

package geniustechspace.idp.v1;

import "buf/validate/validate.proto";
import "google/protobuf/duration.proto";
import "proto/idp/v1/enums.proto";

option csharp_namespace = "GeniusTechSpace.Protobuf.Idp.V1";
option go_package = "github.com/geniustechspace/protobuf/gen/go/idp/v1;idpv1";
option java_multiple_files = true;
option java_package = "com.geniustechspace.protobuf.idp.v1";

// ========== PASSWORD POLICY ==========

// PasswordPolicy - Tenant-specific password requirements
// COMPLIANCE: NIST 800-63B Section 5.1.1
message PasswordPolicy {
  reserved 20 to 50;

  // Policy identifier
  string policy_id = 1 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
  }];

  // Tenant ID
  string tenant_id = 2 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
  }];

  // Minimum length (NIST recommends 8, PCI DSS requires 12 for systems)
  int32 min_length = 3 [(buf.validate.field).int32 = {
    gte: 8
    lte: 128
  }];

  // Maximum length (prevent DoS)
  int32 max_length = 4 [(buf.validate.field).int32 = {
    gte: 8
    lte: 128
  }];

  // Require uppercase letter
  bool require_uppercase = 5;

  // Require lowercase letter
  bool require_lowercase = 6;

  // Require digit
  bool require_digit = 7;

  // Require special character
  bool require_special_char = 8;

  // Special characters allowed (if empty, use default set)
  string allowed_special_chars = 9 [(buf.validate.field).string = {
    max_len: 100
    ignore_empty: true
  }];

  // Prevent password reuse (number of previous passwords to check)
  int32 password_history = 10 [(buf.validate.field).int32 = {
    gte: 0
    lte: 24
  }];

  // Password expiration (0 = never expires)
  // NOTE: NIST 800-63B no longer recommends expiration unless compromise
  google.protobuf.Duration password_expiration = 11;

  // Minimum time between password changes (prevent rapid changes to bypass history)
  google.protobuf.Duration min_password_age = 12;

  // Check against common password lists (recommended by NIST)
  bool check_common_passwords = 13;

  // Check against breached password databases (e.g., Have I Been Pwned)
  bool check_breached_passwords = 14;

  // Prevent username in password
  bool prevent_username_in_password = 15;

  // Active/inactive status
  bool is_active = 16;

  // Metadata
  map<string, string> metadata = 51;
}

// PasswordStrength - Real-time password strength assessment
message PasswordStrength {
  reserved 10 to 50;

  // Strength score (0-100)
  int32 score = 1 [(buf.validate.field).int32 = {
    gte: 0
    lte: 100
  }];

  // Strength level
  enum Level {
    LEVEL_UNSPECIFIED = 0;
    LEVEL_VERY_WEAK = 1;    // Score 0-20
    LEVEL_WEAK = 2;         // Score 21-40
    LEVEL_FAIR = 3;         // Score 41-60
    LEVEL_GOOD = 4;         // Score 61-80
    LEVEL_STRONG = 5;       // Score 81-100
  }
  Level level = 2;

  // Issues found
  repeated string issues = 3 [(buf.validate.field).repeated.max_items = 20];

  // Suggestions for improvement
  repeated string suggestions = 4 [(buf.validate.field).repeated.max_items = 20];

  // Estimated crack time (e.g., "less than a second", "centuries")
  string crack_time = 5 [(buf.validate.field).string.max_len = 100];

  // Found in breached databases
  bool is_breached = 6;

  // Found in common password lists
  bool is_common = 7;
}

// ========== RATE LIMITING ==========

// RateLimitPolicy - Prevent brute force and abuse
// COMPLIANCE: OWASP Authentication Cheat Sheet
message RateLimitPolicy {
  reserved 20 to 50;

  // Policy identifier
  string policy_id = 1 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
  }];

  // Tenant ID
  string tenant_id = 2 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
  }];

  // Operation being limited (e.g., "login", "password_reset", "mfa_verify")
  string operation = 3 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
  }];

  // Scope of rate limiting
  enum Scope {
    SCOPE_UNSPECIFIED = 0;
    SCOPE_GLOBAL = 1;       // Global limit across all tenants
    SCOPE_TENANT = 2;       // Per-tenant limit
    SCOPE_USER = 3;         // Per-user limit
    SCOPE_IP = 4;           // Per-IP address limit
    SCOPE_DEVICE = 5;       // Per-device limit
    SCOPE_CLIENT = 6;       // Per-client application limit
  }
  Scope scope = 4;

  // Maximum requests
  int32 max_requests = 5 [(buf.validate.field).int32 = {
    gte: 1
    lte: 10000
  }];

  // Time window for rate limit
  google.protobuf.Duration window = 6;

  // Burst allowance (allow temporary spike above limit)
  int32 burst_allowance = 7 [(buf.validate.field).int32 = {
    gte: 0
    lte: 1000
  }];

  // Exponential backoff multiplier (1 = no backoff)
  double backoff_multiplier = 8 [(buf.validate.field).double = {
    gte: 1.0
    lte: 10.0
  }];

  // Maximum backoff duration
  google.protobuf.Duration max_backoff = 9;

  // Action when limit exceeded
  enum Action {
    ACTION_UNSPECIFIED = 0;
    ACTION_REJECT = 1;          // Reject request immediately
    ACTION_DELAY = 2;           // Add delay before processing
    ACTION_CAPTCHA = 3;         // Require CAPTCHA verification
    ACTION_LOCKOUT = 4;         // Trigger account lockout
  }
  Action action = 10;

  // Active/inactive status
  bool is_active = 11;

  // Metadata
  map<string, string> metadata = 51;
}

// RateLimitStatus - Current rate limit state for a subject
message RateLimitStatus {
  reserved 10 to 50;

  // Subject identifier (user_id, ip_address, device_id, etc.)
  string subject_id = 1 [(buf.validate.field).string = {
    min_len: 1
    max_len: 128
  }];

  // Tenant ID
  string tenant_id = 2 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
  }];

  // Operation
  string operation = 3 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
  }];

  // Requests made in current window
  int32 requests_made = 4 [(buf.validate.field).int32.gte = 0];

  // Maximum requests allowed
  int32 max_requests = 5 [(buf.validate.field).int32.gte = 0];

  // Remaining requests
  int32 remaining_requests = 6 [(buf.validate.field).int32.gte = 0];

  // Window reset time
  google.protobuf.Timestamp reset_at = 7;

  // Currently rate limited
  bool is_limited = 8;

  // Current backoff duration (if applicable)
  google.protobuf.Duration backoff_duration = 9;
}

// ========== ACCOUNT LOCKOUT ==========

// AccountLockoutPolicy - Prevent brute force attacks
// COMPLIANCE: OWASP, PCI DSS 8.1.6
message AccountLockoutPolicy {
  reserved 20 to 50;

  // Policy identifier
  string policy_id = 1 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
  }];

  // Tenant ID
  string tenant_id = 2 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
  }];

  // Failed attempts before lockout (OWASP recommends 5-10)
  int32 max_failed_attempts = 3 [(buf.validate.field).int32 = {
    gte: 3
    lte: 100
  }];

  // Time window to count failed attempts
  google.protobuf.Duration attempt_window = 4;

  // Lockout duration (0 = requires admin unlock)
  google.protobuf.Duration lockout_duration = 5;

  // Progressive lockout (increase duration with repeated lockouts)
  bool progressive_lockout = 6;

  // Notify user on lockout
  bool notify_on_lockout = 7;

  // Notify admin on lockout
  bool notify_admin_on_lockout = 8;

  // Lockout applies to
  enum Scope {
    SCOPE_UNSPECIFIED = 0;
    SCOPE_ACCOUNT = 1;      // Lock entire account
    SCOPE_IP = 2;           // Lock IP address
    SCOPE_DEVICE = 3;       // Lock device
    SCOPE_COMBINATION = 4;  // Lock account + IP + device combination
  }
  Scope scope = 9;

  // Active/inactive status
  bool is_active = 10;

  // Metadata
  map<string, string> metadata = 51;
}

// AccountLockoutStatus - Current lockout state for an account
message AccountLockoutStatus {
  reserved 10 to 50;

  // Account identifier (user_id, ip_address, device_id)
  string account_id = 1 [(buf.validate.field).string = {
    min_len: 1
    max_len: 128
  }];

  // Tenant ID
  string tenant_id = 2 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
  }];

  // Currently locked
  bool is_locked = 3;

  // Failed attempts in current window
  int32 failed_attempts = 4 [(buf.validate.field).int32.gte = 0];

  // Maximum allowed attempts
  int32 max_attempts = 5 [(buf.validate.field).int32.gte = 0];

  // Remaining attempts before lockout
  int32 remaining_attempts = 6 [(buf.validate.field).int32.gte = 0];

  // Lockout start time (if locked)
  google.protobuf.Timestamp locked_at = 7;

  // Lockout end time (if locked and auto-unlock enabled)
  google.protobuf.Timestamp unlock_at = 8;

  // Number of times locked (for progressive lockout)
  int32 lockout_count = 9 [(buf.validate.field).int32.gte = 0];
}

// ========== RISK ASSESSMENT ==========

// RiskAssessmentPolicy - Configure risk-based authentication
// COMPLIANCE: NIST 800-63B, FFIEC Authentication Guidance
message RiskAssessmentPolicy {
  reserved 20 to 50;

  // Policy identifier
  string policy_id = 1 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
  }];

  // Tenant ID
  string tenant_id = 2 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
  }];

  // Risk factors to evaluate
  message RiskFactor {
    reserved 10 to 20;

    // Factor name (e.g., "new_device", "unusual_location", "impossible_travel")
    string name = 1 [(buf.validate.field).string = {
      min_len: 1
      max_len: 64
    }];

    // Weight in risk score calculation (0-1)
    double weight = 2 [(buf.validate.field).double = {
      gte: 0.0
      lte: 1.0
    }];

    // Enabled
    bool enabled = 3;
  }
  repeated RiskFactor risk_factors = 3 [(buf.validate.field).repeated.max_items = 50];

  // Risk level thresholds
  message RiskThresholds {
    int32 low_threshold = 1 [(buf.validate.field).int32 = {gte: 0, lte: 100}];      // 0-30
    int32 medium_threshold = 2 [(buf.validate.field).int32 = {gte: 0, lte: 100}];   // 31-60
    int32 high_threshold = 3 [(buf.validate.field).int32 = {gte: 0, lte: 100}];     // 61-85
    int32 critical_threshold = 4 [(buf.validate.field).int32 = {gte: 0, lte: 100}]; // 86-100
  }
  RiskThresholds thresholds = 4;

  // Actions by risk level
  message RiskAction {
    reserved 10 to 20;

    RiskLevel risk_level = 1;
    
    enum Action {
      ACTION_UNSPECIFIED = 0;
      ACTION_ALLOW = 1;               // Allow authentication
      ACTION_CHALLENGE_MFA = 2;       // Require MFA
      ACTION_STEP_UP = 3;             // Require stronger authentication
      ACTION_BLOCK = 4;               // Block authentication
      ACTION_NOTIFY_USER = 5;         // Notify user of suspicious activity
      ACTION_NOTIFY_ADMIN = 6;        // Notify admin
      ACTION_MANUAL_REVIEW = 7;       // Flag for manual review
    }
    repeated Action actions = 2 [(buf.validate.field).repeated.max_items = 10];
  }
  repeated RiskAction risk_actions = 5 [(buf.validate.field).repeated.max_items = 10];

  // Active/inactive status
  bool is_active = 6;

  // Metadata
  map<string, string> metadata = 51;
}

// RiskScore - Calculated risk score for an authentication attempt
message RiskScore {
  reserved 20 to 50;

  // Overall risk score (0-100)
  int32 score = 1 [(buf.validate.field).int32 = {
    gte: 0
    lte: 100
  }];

  // Risk level classification
  RiskLevel level = 2;

  // Risk factors detected
  message DetectedFactor {
    reserved 10 to 20;

    // Factor name
    string name = 1 [(buf.validate.field).string = {
      min_len: 1
      max_len: 64
    }];

    // Contribution to total score
    int32 score_contribution = 2 [(buf.validate.field).int32 = {
      gte: 0
      lte: 100
    }];

    // Factor description
    string description = 3 [(buf.validate.field).string.max_len = 500];

    // Factor severity
    enum Severity {
      SEVERITY_UNSPECIFIED = 0;
      SEVERITY_INFO = 1;
      SEVERITY_LOW = 2;
      SEVERITY_MEDIUM = 3;
      SEVERITY_HIGH = 4;
      SEVERITY_CRITICAL = 5;
    }
    Severity severity = 4;
  }
  repeated DetectedFactor detected_factors = 3 [(buf.validate.field).repeated.max_items = 50];

  // Recommended actions
  repeated string recommended_actions = 4 [(buf.validate.field).repeated.max_items = 10];

  // Reason for risk level
  string reason = 5 [(buf.validate.field).string.max_len = 1000];

  // Requires additional verification
  bool requires_step_up = 6;

  // Assessment timestamp
  google.protobuf.Timestamp assessed_at = 7;

  // Metadata
  map<string, string> metadata = 51;
}
